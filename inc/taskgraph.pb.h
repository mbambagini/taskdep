// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: taskgraph.proto

#ifndef PROTOBUF_taskgraph_2eproto__INCLUDED
#define PROTOBUF_taskgraph_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace TaskGraph {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_taskgraph_2eproto();
void protobuf_AssignDesc_taskgraph_2eproto();
void protobuf_ShutdownFile_taskgraph_2eproto();

class Task;
class Dependency;
class Graph;

// ===================================================================

class Task : public ::google::protobuf::Message {
 public:
  Task();
  virtual ~Task();
  
  Task(const Task& from);
  
  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();
  
  void Swap(Task* other);
  
  // implements Message ----------------------------------------------
  
  Task* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 wcet = 3;
  inline bool has_wcet() const;
  inline void clear_wcet();
  static const int kWcetFieldNumber = 3;
  inline ::google::protobuf::int32 wcet() const;
  inline void set_wcet(::google::protobuf::int32 value);
  
  // optional int32 sync = 4;
  inline bool has_sync() const;
  inline void clear_sync();
  static const int kSyncFieldNumber = 4;
  inline ::google::protobuf::int32 sync() const;
  inline void set_sync(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:TaskGraph.Task)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_wcet();
  inline void clear_has_wcet();
  inline void set_has_sync();
  inline void clear_has_sync();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 wcet_;
  ::google::protobuf::int32 sync_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_taskgraph_2eproto();
  friend void protobuf_AssignDesc_taskgraph_2eproto();
  friend void protobuf_ShutdownFile_taskgraph_2eproto();
  
  void InitAsDefaultInstance();
  static Task* default_instance_;
};
// -------------------------------------------------------------------

class Dependency : public ::google::protobuf::Message {
 public:
  Dependency();
  virtual ~Dependency();
  
  Dependency(const Dependency& from);
  
  inline Dependency& operator=(const Dependency& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Dependency& default_instance();
  
  void Swap(Dependency* other);
  
  // implements Message ----------------------------------------------
  
  Dependency* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Dependency& from);
  void MergeFrom(const Dependency& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string fromTask = 1;
  inline bool has_fromtask() const;
  inline void clear_fromtask();
  static const int kFromTaskFieldNumber = 1;
  inline const ::std::string& fromtask() const;
  inline void set_fromtask(const ::std::string& value);
  inline void set_fromtask(const char* value);
  inline void set_fromtask(const char* value, size_t size);
  inline ::std::string* mutable_fromtask();
  inline ::std::string* release_fromtask();
  
  // required string toTask = 2;
  inline bool has_totask() const;
  inline void clear_totask();
  static const int kToTaskFieldNumber = 2;
  inline const ::std::string& totask() const;
  inline void set_totask(const ::std::string& value);
  inline void set_totask(const char* value);
  inline void set_totask(const char* value, size_t size);
  inline ::std::string* mutable_totask();
  inline ::std::string* release_totask();
  
  // required int32 exchangedData = 3;
  inline bool has_exchangeddata() const;
  inline void clear_exchangeddata();
  static const int kExchangedDataFieldNumber = 3;
  inline ::google::protobuf::int32 exchangeddata() const;
  inline void set_exchangeddata(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:TaskGraph.Dependency)
 private:
  inline void set_has_fromtask();
  inline void clear_has_fromtask();
  inline void set_has_totask();
  inline void clear_has_totask();
  inline void set_has_exchangeddata();
  inline void clear_has_exchangeddata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* fromtask_;
  ::std::string* totask_;
  ::google::protobuf::int32 exchangeddata_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_taskgraph_2eproto();
  friend void protobuf_AssignDesc_taskgraph_2eproto();
  friend void protobuf_ShutdownFile_taskgraph_2eproto();
  
  void InitAsDefaultInstance();
  static Dependency* default_instance_;
};
// -------------------------------------------------------------------

class Graph : public ::google::protobuf::Message {
 public:
  Graph();
  virtual ~Graph();
  
  Graph(const Graph& from);
  
  inline Graph& operator=(const Graph& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Graph& default_instance();
  
  void Swap(Graph* other);
  
  // implements Message ----------------------------------------------
  
  Graph* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Graph& from);
  void MergeFrom(const Graph& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 maxWcet = 1;
  inline bool has_maxwcet() const;
  inline void clear_maxwcet();
  static const int kMaxWcetFieldNumber = 1;
  inline ::google::protobuf::int32 maxwcet() const;
  inline void set_maxwcet(::google::protobuf::int32 value);
  
  // required int32 minWcet = 2;
  inline bool has_minwcet() const;
  inline void clear_minwcet();
  static const int kMinWcetFieldNumber = 2;
  inline ::google::protobuf::int32 minwcet() const;
  inline void set_minwcet(::google::protobuf::int32 value);
  
  // required int32 maxExchangedData = 3;
  inline bool has_maxexchangeddata() const;
  inline void clear_maxexchangeddata();
  static const int kMaxExchangedDataFieldNumber = 3;
  inline ::google::protobuf::int32 maxexchangeddata() const;
  inline void set_maxexchangeddata(::google::protobuf::int32 value);
  
  // required int32 minExchangedData = 4;
  inline bool has_minexchangeddata() const;
  inline void clear_minexchangeddata();
  static const int kMinExchangedDataFieldNumber = 4;
  inline ::google::protobuf::int32 minexchangeddata() const;
  inline void set_minexchangeddata(::google::protobuf::int32 value);
  
  // repeated .TaskGraph.Task tasks = 5;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 5;
  inline const ::TaskGraph::Task& tasks(int index) const;
  inline ::TaskGraph::Task* mutable_tasks(int index);
  inline ::TaskGraph::Task* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::TaskGraph::Task >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::TaskGraph::Task >*
      mutable_tasks();
  
  // repeated .TaskGraph.Dependency dependencies = 6;
  inline int dependencies_size() const;
  inline void clear_dependencies();
  static const int kDependenciesFieldNumber = 6;
  inline const ::TaskGraph::Dependency& dependencies(int index) const;
  inline ::TaskGraph::Dependency* mutable_dependencies(int index);
  inline ::TaskGraph::Dependency* add_dependencies();
  inline const ::google::protobuf::RepeatedPtrField< ::TaskGraph::Dependency >&
      dependencies() const;
  inline ::google::protobuf::RepeatedPtrField< ::TaskGraph::Dependency >*
      mutable_dependencies();
  
  // @@protoc_insertion_point(class_scope:TaskGraph.Graph)
 private:
  inline void set_has_maxwcet();
  inline void clear_has_maxwcet();
  inline void set_has_minwcet();
  inline void clear_has_minwcet();
  inline void set_has_maxexchangeddata();
  inline void clear_has_maxexchangeddata();
  inline void set_has_minexchangeddata();
  inline void clear_has_minexchangeddata();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 maxwcet_;
  ::google::protobuf::int32 minwcet_;
  ::google::protobuf::int32 maxexchangeddata_;
  ::google::protobuf::int32 minexchangeddata_;
  ::google::protobuf::RepeatedPtrField< ::TaskGraph::Task > tasks_;
  ::google::protobuf::RepeatedPtrField< ::TaskGraph::Dependency > dependencies_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_taskgraph_2eproto();
  friend void protobuf_AssignDesc_taskgraph_2eproto();
  friend void protobuf_ShutdownFile_taskgraph_2eproto();
  
  void InitAsDefaultInstance();
  static Graph* default_instance_;
};
// ===================================================================


// ===================================================================

// Task

// required int32 id = 1;
inline bool Task::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Task::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Task::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Task::id() const {
  return id_;
}
inline void Task::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool Task::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Task::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Task::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Task::name() const {
  return *name_;
}
inline void Task::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Task::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Task::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Task::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 wcet = 3;
inline bool Task::has_wcet() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Task::set_has_wcet() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Task::clear_has_wcet() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Task::clear_wcet() {
  wcet_ = 0;
  clear_has_wcet();
}
inline ::google::protobuf::int32 Task::wcet() const {
  return wcet_;
}
inline void Task::set_wcet(::google::protobuf::int32 value) {
  set_has_wcet();
  wcet_ = value;
}

// optional int32 sync = 4;
inline bool Task::has_sync() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Task::set_has_sync() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Task::clear_has_sync() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Task::clear_sync() {
  sync_ = 0;
  clear_has_sync();
}
inline ::google::protobuf::int32 Task::sync() const {
  return sync_;
}
inline void Task::set_sync(::google::protobuf::int32 value) {
  set_has_sync();
  sync_ = value;
}

// -------------------------------------------------------------------

// Dependency

// required string fromTask = 1;
inline bool Dependency::has_fromtask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Dependency::set_has_fromtask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Dependency::clear_has_fromtask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Dependency::clear_fromtask() {
  if (fromtask_ != &::google::protobuf::internal::kEmptyString) {
    fromtask_->clear();
  }
  clear_has_fromtask();
}
inline const ::std::string& Dependency::fromtask() const {
  return *fromtask_;
}
inline void Dependency::set_fromtask(const ::std::string& value) {
  set_has_fromtask();
  if (fromtask_ == &::google::protobuf::internal::kEmptyString) {
    fromtask_ = new ::std::string;
  }
  fromtask_->assign(value);
}
inline void Dependency::set_fromtask(const char* value) {
  set_has_fromtask();
  if (fromtask_ == &::google::protobuf::internal::kEmptyString) {
    fromtask_ = new ::std::string;
  }
  fromtask_->assign(value);
}
inline void Dependency::set_fromtask(const char* value, size_t size) {
  set_has_fromtask();
  if (fromtask_ == &::google::protobuf::internal::kEmptyString) {
    fromtask_ = new ::std::string;
  }
  fromtask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Dependency::mutable_fromtask() {
  set_has_fromtask();
  if (fromtask_ == &::google::protobuf::internal::kEmptyString) {
    fromtask_ = new ::std::string;
  }
  return fromtask_;
}
inline ::std::string* Dependency::release_fromtask() {
  clear_has_fromtask();
  if (fromtask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromtask_;
    fromtask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string toTask = 2;
inline bool Dependency::has_totask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Dependency::set_has_totask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Dependency::clear_has_totask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Dependency::clear_totask() {
  if (totask_ != &::google::protobuf::internal::kEmptyString) {
    totask_->clear();
  }
  clear_has_totask();
}
inline const ::std::string& Dependency::totask() const {
  return *totask_;
}
inline void Dependency::set_totask(const ::std::string& value) {
  set_has_totask();
  if (totask_ == &::google::protobuf::internal::kEmptyString) {
    totask_ = new ::std::string;
  }
  totask_->assign(value);
}
inline void Dependency::set_totask(const char* value) {
  set_has_totask();
  if (totask_ == &::google::protobuf::internal::kEmptyString) {
    totask_ = new ::std::string;
  }
  totask_->assign(value);
}
inline void Dependency::set_totask(const char* value, size_t size) {
  set_has_totask();
  if (totask_ == &::google::protobuf::internal::kEmptyString) {
    totask_ = new ::std::string;
  }
  totask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Dependency::mutable_totask() {
  set_has_totask();
  if (totask_ == &::google::protobuf::internal::kEmptyString) {
    totask_ = new ::std::string;
  }
  return totask_;
}
inline ::std::string* Dependency::release_totask() {
  clear_has_totask();
  if (totask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = totask_;
    totask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 exchangedData = 3;
inline bool Dependency::has_exchangeddata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Dependency::set_has_exchangeddata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Dependency::clear_has_exchangeddata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Dependency::clear_exchangeddata() {
  exchangeddata_ = 0;
  clear_has_exchangeddata();
}
inline ::google::protobuf::int32 Dependency::exchangeddata() const {
  return exchangeddata_;
}
inline void Dependency::set_exchangeddata(::google::protobuf::int32 value) {
  set_has_exchangeddata();
  exchangeddata_ = value;
}

// -------------------------------------------------------------------

// Graph

// required int32 maxWcet = 1;
inline bool Graph::has_maxwcet() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Graph::set_has_maxwcet() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Graph::clear_has_maxwcet() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Graph::clear_maxwcet() {
  maxwcet_ = 0;
  clear_has_maxwcet();
}
inline ::google::protobuf::int32 Graph::maxwcet() const {
  return maxwcet_;
}
inline void Graph::set_maxwcet(::google::protobuf::int32 value) {
  set_has_maxwcet();
  maxwcet_ = value;
}

// required int32 minWcet = 2;
inline bool Graph::has_minwcet() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Graph::set_has_minwcet() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Graph::clear_has_minwcet() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Graph::clear_minwcet() {
  minwcet_ = 0;
  clear_has_minwcet();
}
inline ::google::protobuf::int32 Graph::minwcet() const {
  return minwcet_;
}
inline void Graph::set_minwcet(::google::protobuf::int32 value) {
  set_has_minwcet();
  minwcet_ = value;
}

// required int32 maxExchangedData = 3;
inline bool Graph::has_maxexchangeddata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Graph::set_has_maxexchangeddata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Graph::clear_has_maxexchangeddata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Graph::clear_maxexchangeddata() {
  maxexchangeddata_ = 0;
  clear_has_maxexchangeddata();
}
inline ::google::protobuf::int32 Graph::maxexchangeddata() const {
  return maxexchangeddata_;
}
inline void Graph::set_maxexchangeddata(::google::protobuf::int32 value) {
  set_has_maxexchangeddata();
  maxexchangeddata_ = value;
}

// required int32 minExchangedData = 4;
inline bool Graph::has_minexchangeddata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Graph::set_has_minexchangeddata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Graph::clear_has_minexchangeddata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Graph::clear_minexchangeddata() {
  minexchangeddata_ = 0;
  clear_has_minexchangeddata();
}
inline ::google::protobuf::int32 Graph::minexchangeddata() const {
  return minexchangeddata_;
}
inline void Graph::set_minexchangeddata(::google::protobuf::int32 value) {
  set_has_minexchangeddata();
  minexchangeddata_ = value;
}

// repeated .TaskGraph.Task tasks = 5;
inline int Graph::tasks_size() const {
  return tasks_.size();
}
inline void Graph::clear_tasks() {
  tasks_.Clear();
}
inline const ::TaskGraph::Task& Graph::tasks(int index) const {
  return tasks_.Get(index);
}
inline ::TaskGraph::Task* Graph::mutable_tasks(int index) {
  return tasks_.Mutable(index);
}
inline ::TaskGraph::Task* Graph::add_tasks() {
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TaskGraph::Task >&
Graph::tasks() const {
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::TaskGraph::Task >*
Graph::mutable_tasks() {
  return &tasks_;
}

// repeated .TaskGraph.Dependency dependencies = 6;
inline int Graph::dependencies_size() const {
  return dependencies_.size();
}
inline void Graph::clear_dependencies() {
  dependencies_.Clear();
}
inline const ::TaskGraph::Dependency& Graph::dependencies(int index) const {
  return dependencies_.Get(index);
}
inline ::TaskGraph::Dependency* Graph::mutable_dependencies(int index) {
  return dependencies_.Mutable(index);
}
inline ::TaskGraph::Dependency* Graph::add_dependencies() {
  return dependencies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TaskGraph::Dependency >&
Graph::dependencies() const {
  return dependencies_;
}
inline ::google::protobuf::RepeatedPtrField< ::TaskGraph::Dependency >*
Graph::mutable_dependencies() {
  return &dependencies_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace TaskGraph

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_taskgraph_2eproto__INCLUDED
